<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiayi771.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Joey&#39;s Notes">
<meta property="og:url" content="http://liujiayi771.github.io/page/2/index.html">
<meta property="og:site_name" content="Joey&#39;s Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jiayi Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiayi771.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Joey's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Joey's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Joey</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">59</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2019/01/18/ubuntu%E5%AE%89%E8%A3%85OpenCL%E8%BF%90%E8%A1%8C%E5%8F%8A%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/ubuntu%E5%AE%89%E8%A3%85OpenCL%E8%BF%90%E8%A1%8C%E5%8F%8A%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">ubuntu安装OpenCL运行及编译环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 09:19:46" itemprop="dateCreated datePublished" datetime="2019-01-18T09:19:46+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近需要运行一个基于OpenCL开发的软件，服务器上的NVIDIA 1080Ti和Intel CPU都支持OpenCL，安装OpenCL之前可以安装一个clinfo的软件可以看到服务器上目前支持的OpenCL设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clinfo</span><br></pre></td></tr></table></figure>
<p>一般安装NVIDIA的驱动的时候就会有选项选择是否安装OpenCL的驱动，若没有选择那个选项，clinfo是看不到有NVIDIA的cl设备的，接下来安装的几个软件一般也会将没有选择OpenCL的NVIDIA缺失的库作为依赖安装上，使得基于NVIDIA的cl设备能够正常使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ocl-icd-libopencl1</span><br><span class="line">sudo apt install opencl-headers</span><br></pre></td></tr></table></figure>
<p>若需要在服务器上编译或者调试OpenCL程序，还需要安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ocl-icd-opencl-dev</span><br></pre></td></tr></table></figure>
<p>要使得CPU也支持运行OpenCL程序，需要去intel官网下载opencl-sdk，地址是:</p>
<p><a target="_blank" rel="noopener" href="http://software.intel.com/en-us/vcsource/tools/opencl-sdk">http://software.intel.com/en-us/vcsource/tools/opencl-sdk</a> </p>
<p>选择runtime版本进行下载，目前最新的适合ubuntu的地址是： </p>
<p><a target="_blank" rel="noopener" href="http://registrationcenter-download.intel.com/akdlm/irc_nas/vcp/12526/opencl_runtime_16.1.2_x64_rh_6.4.0.37.tgz">http://registrationcenter-download.intel.com/akdlm/irc_nas/vcp/12526/opencl_runtime_16.1.2_x64_rh_6.4.0.37.tgz</a> </p>
<p>适合CentOS的地址是： </p>
<p><a target="_blank" rel="noopener" href="http://registrationcenter-download.intel.com/akdlm/irc_nas/vcp/13454/opencl_runtime_16.1.2_x64_rh_6.4.0.37.tgz">http://registrationcenter-download.intel.com/akdlm/irc_nas/vcp/13454/opencl_runtime_16.1.2_x64_rh_6.4.0.37.tgz</a> </p>
<p>安装前需要先安装<code>lsb-core</code>，sdk依赖于这个库，版本必须大于4.0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lsb-core</span><br></pre></td></tr></table></figure>
<p>CentOS系统为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install redhat-lsb-core</span><br></pre></td></tr></table></figure>
<p>之后<code>sudo ./install</code>，检查操作系统版本时会提出ubuntu not support，这里可以忽略，这里说的只是不提供支持，而不是不能够使用，intel官方回复说对centos系统提供较好的支持，但ubuntu也是能使用的。</p>
<blockquote>
<ol>
<li>The OpenCL™ implemenations themselves provided at the link are supported. Intel® CPU Runtime for OpenCL™ Applications on Ubuntu* OS is supported. This support is distinct from the 2017 SDK support.</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>The 2017 SDK is supported on CentOS*. It is expected compatible with Ubuntu* OS.</li>
</ol>
</blockquote>
<blockquote>
<p>The semantic difference is that for supported there is an immediate paid path to get priority support and an intent to create service level agreements for CentOS* only. ‘supported’ is an overloaded word in the software industry… Hopefully the installer messaging will be more clear in the upcoming 2019 SDK.</p>
</blockquote>
<p>具体可以看 <a target="_blank" rel="noopener" href="https://software.intel.com/en-us/forums/opencl/topic/785262">https://software.intel.com/en-us/forums/opencl/topic/785262</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/12/12/linux/Linux%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/12/linux/Linux%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E7%9B%98/" class="post-title-link" itemprop="url">Linux初始化及挂载数据盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-12 11:24:40" itemprop="dateCreated datePublished" datetime="2018-12-12T11:24:40+08:00">2018-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="磁盘分区形式"><a href="#磁盘分区形式" class="headerlink" title="磁盘分区形式"></a>磁盘分区形式</h2><p>常用的磁盘分区形式如下表所示，并且针对Linux操作系统，不同的磁盘分区形式需要选择不同的分区工具。</p>
<table>
<thead>
<tr>
<th>磁盘分区形式</th>
<th align="center">支持最大磁盘容量</th>
<th align="left">支持分区数量</th>
<th align="left">Linux分区工具</th>
</tr>
</thead>
<tbody><tr>
<td>主启动记录分区（MBR）</td>
<td align="center">2TB</td>
<td align="left"><li>4个主分区</li><li>3个主分区和1个扩展分区</li><br>说明：<br>MBR分区包含主分区和扩展分<br>区，其中扩展分区里面可以包<br>含若干个逻辑分区。以创建六<br>个分区为例，以下两种分区情<br>况供参考：<br><li>3个主分区，一个扩展分区，<br>其中扩展分区包含3个逻辑分<br>区。</li><li>1个主分区，1个扩展分区，<br>其中扩展分区中包含5个逻辑<br>分区。</li></td>
<td align="left">以下两种工具均可以使用：<br><li>fdisk工具</li><li>parted工具</li></td>
</tr>
<tr>
<td>全局分区表<br>(GPT, Guid Partition Table)</td>
<td align="center">18EB<br>(1EB&#x3D;1048576TB)</td>
<td align="left">不限制分区数量<br>说明：<br>GPT格式下没有主分区、扩展分区以及逻辑分区之分</td>
<td align="left">parted工具</td>
</tr>
</tbody></table>
<blockquote>
<p>注意事项：<br>MBR格式分区最大支持的容量是2TB，如果硬盘的容量大于2TB，则必须选择GPT的分区形式，并且使用parted进行分区。当磁盘已经投入使用后，此时切换磁盘分区形式时，磁盘上的原有数据将会被清除，因此请在磁盘初始化时谨慎选择磁盘分区形式。</p>
</blockquote>
<h2 id="使用fdisk工具初始化磁盘（只支持小于2TB的硬盘）"><a href="#使用fdisk工具初始化磁盘（只支持小于2TB的硬盘）" class="headerlink" title="使用fdisk工具初始化磁盘（只支持小于2TB的硬盘）"></a>使用fdisk工具初始化磁盘（只支持小于2TB的硬盘）</h2><ol>
<li><p><code>fdisk -l</code>查看新增数据盘的信息，一般可以看到例如<code>/dev/sdb</code>这样的新增盘，主要依据是根据显示的信息中显示的硬盘大小以及是否有分区。<br> 一般会显示如下信息（以下信息为分区后的情况，若新硬盘会看到一个没有分区的磁盘）：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">磁盘 /dev/sda：1000.2 GB, 1000204886016 字节，1953525168 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 4096 字节</span><br><span class="line">I/O 大小(最小/最佳)：4096 字节 / 4096 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000c5dbf</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048   125001727    62499840   82  Linux swap / Solaris</span><br><span class="line">/dev/sda2   *   125001728  1953523711   914260992   83  Linux</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：6001.2 GB, 6001175126016 字节，11721045168 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 4096 字节</span><br><span class="line">I/O 大小(最小/最佳)：4096 字节 / 4096 字节</span><br><span class="line">磁盘标签类型：gpt</span><br><span class="line">Disk identifier: E9D9D767-8701-4230-BFAC-07F103EBB35A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\<span class="comment">#         Start          End    Size  Type            Name</span></span><br><span class="line"> 1         2048  11721043967    5.5T  Microsoft basic data</span><br></pre></td></tr></table></figure></li>
<li><p><code>fdisk 新增数据盘</code>，例如<code>fdisk /dev/sdb</code></p>
</li>
<li><p>输入n，按Enter开始新建分区，这里n代表new</p>
</li>
<li><p>接下来会让我们选择p还是e，p代表主要分区，e代表延伸分区，对于新增加的硬盘一般选择p</p>
</li>
<li><p>选择分区号，对于新增硬盘，一般选择1</p>
</li>
<li><p>选择初始磁柱编号，新增硬盘选择默认的2048即可</p>
</li>
<li><p>选择截止磁柱区域，选择默认的最大的磁柱区域即可，表示只建立一个分区，这个分区使用了硬盘的所有容量</p>
</li>
<li><p>输入p，可以看到我们已经新建好的硬盘分区为<code>/dev/sdb1</code></p>
</li>
<li><p>输入w，按Enter将分区结果写入分区表</p>
</li>
<li><p>执行<code>partprobe</code>将新的分区表变更同步至操作系统</p>
</li>
</ol>
<h2 id="使用parted工具初始化磁盘（可以支持大于2TB的硬盘）"><a href="#使用parted工具初始化磁盘（可以支持大于2TB的硬盘）" class="headerlink" title="使用parted工具初始化磁盘（可以支持大于2TB的硬盘）"></a>使用parted工具初始化磁盘（可以支持大于2TB的硬盘）</h2><ol>
<li><p><code>lsblk</code>查看新增数据盘信息，和上一个介绍的工具的<code>fdisk -l</code>的效果是一样的，可以看到例如<code>/dev/sdb</code>这样的新增盘，并且这种方式显示出来的结果更加直观一点，冗余的信息比较少。<br> 一般会显示如下信息（以下信息为分区后的情况，若新硬盘会看到一个没有分区的磁盘）：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:16   0 931.5G  0 disk</span><br><span class="line">├─sda1   8:17   0  59.6G  0 part</span><br><span class="line">└─sda2   8:18   0 871.9G  0 part /</span><br><span class="line">sdb      8:0    0   5.5T  0 disk</span><br><span class="line">└─sdb1   8:1    0   5.5T  0 part /mnt/data</span><br></pre></td></tr></table></figure></li>
<li><p><code>parted 新增数据盘</code>，例如<code>parted /dev/sdb</code></p>
</li>
<li><p>输入p，按Enter查看当前磁盘的分区形式</p>
</li>
<li><p>输入以下命令，设置磁盘分区形式。<code>mklabel 磁盘分区形式</code>，这里磁盘分区形式可以选择GPT和MBR，当然，大于2TB的硬盘只能选择GPT</p>
</li>
<li><p>输入<code>unit s</code>，按Enter，设置磁盘的计量单位为磁柱</p>
</li>
<li><p>以为整个磁盘创建一个分区为例，输入<code>mkparted data 2048s 100%</code>，按Enter。这里data为分区名称，2048s表示初始磁柱位置，100%表示从初始磁柱位置开始，占用100%的磁盘容量进行新建分区</p>
</li>
<li><p>输入q，按Enter，退出parted</p>
</li>
</ol>
<h2 id="格式化数据盘及挂载数据盘"><a href="#格式化数据盘及挂载数据盘" class="headerlink" title="格式化数据盘及挂载数据盘"></a>格式化数据盘及挂载数据盘</h2><p>数据盘分区好之后是不能直接挂载的，会显示unknown filesystem，需要进行格式化指定一个磁盘文件格式，以ext4格式为例，使用如下指令进行格式化:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>
<p>之后便可以新建一个文件夹，例如<code>/mnt/data</code>将新硬盘挂载到该文件夹下，输入如下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt/data</span><br></pre></td></tr></table></figure>

<p>这样做只能即使生效，重启后需要重新输入指令进行挂载，十分不方便，可以将磁盘挂载写入到<code>/etc/fstab</code>文件当中，这样就可以省去每次开机挂载的繁琐操作。首先使用<code>blkid /dev/sdb1</code>来查看新增分区的UUID号是多少，复制UUID，编辑<code>/etc/fstab</code>文件，在末尾加入一行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=1851e23f-1c57-40ab-86bb-5fc5fc606ffa /mnt/data      ext4 defaults     0   2</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/11/13/ansible%E6%95%99%E7%A8%8B%E4%B9%8Bfile%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/13/ansible%E6%95%99%E7%A8%8B%E4%B9%8Bfile%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">ansible教程之file模块的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-13 09:30:07" itemprop="dateCreated datePublished" datetime="2018-11-13T09:30:07+08:00">2018-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ansible是一个自动化运维非常重要的工具，对于做大数据开发的人来说，ansible是一个管理集群的利器，我们可以用它来在集群中批量执行一些指令，而不需要对服务器一台一台进行操作。ansible的功能非常多，但是对于我来说一般只用来在集群中批量执行一些命令，例如批量安装软件、批量删除文件、批量新建文件夹等，具体详细的功能可以参考这个中文文档 <a target="_blank" rel="noopener" href="http://www.ansible.com.cn/docs/">ansible中文权威指南</a>。</p>
<h3 id="用ansible对集群中文件进行管理"><a href="#用ansible对集群中文件进行管理" class="headerlink" title="用ansible对集群中文件进行管理"></a>用ansible对集群中文件进行管理</h3><p>有时候我们可能需要在集群中批量删除某些文件，例如有时候spark slave节点上的work文件夹中的无用文件太多，又没有被自动清除，我们可以使用如下ansible指令来对文件夹中的文件进行批量删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible spark -m shell -a &quot;rm -rf /usr/local/spark/work/*&quot;</span><br></pre></td></tr></table></figure>
<p>这样做确实能正确将work文件夹中的内容都删除掉，但是会收到一个警告信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[WARNING]: Consider using the file module with state=absent rather than running rm.  If you need to use command because file is insufficient you can add warn=False to this command task or set command_warnings=False in ansible.cfg to get</span><br><span class="line">rid of this message.</span><br></pre></td></tr></table></figure>
<p>其实，这里<code>-m</code>后面接的参数就是使用的module，这里用了ansible的shell模块在每台机器上运行shell command进行删除操作，warning中也告诉了我们，ansible中有一个file模块可以用来做文件处理的操作。</p>
<h3 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a>file模块</h3><p>file模块的功能非常多，官方文档是这样描述的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sets attributes of files, symlinks, and directories, or removes files/symlinks/directories. Many other modules support the same options as the `file&#x27; module - including [copy], [template], and [assemble].</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>ansible-doc file</code>来查看file模块的详细使用文档（精简版可以使用<code>ansible-doc -s file</code>），这里举几个常用的例子来介绍file模块的使用。</p>
<h4 id="file模块删除文件或目录"><a href="#file模块删除文件或目录" class="headerlink" title="file模块删除文件或目录"></a>file模块删除文件或目录</h4><p>正如前面所说的删除文件的方法，用file模块的使用方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ansible spark -m file -a &quot;path=/usr/local/spark/work/* state=absent&quot;</span><br><span class="line">dell-r730-2 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;path&quot;: &quot;/usr/local/spark/work/*&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;absent&quot;</span><br><span class="line">&#125;</span><br><span class="line">dell-r730-4 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;path&quot;: &quot;/usr/local/spark/work/*&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;absent&quot;</span><br><span class="line">&#125;</span><br><span class="line">dell-r730-3 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;path&quot;: &quot;/usr/local/spark/work/*&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;absent&quot;</span><br><span class="line">&#125;</span><br><span class="line">dell-r730-1 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;path&quot;: &quot;/usr/local/spark/work/*&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;absent&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能达到将<code>/usr/local/spark/work</code>目录中的<code>app-xxx</code>目录删除的目的，这里<code>-m</code>参数后面指定了使用file模块，<code>-a</code>参数后面为模块的参数，指定了文件或目录的路径<code>path</code>，以及状态<code>state=absent</code>，表示将指定的path进行删除处理。</p>
<h4 id="file模块新建一个文件或目录"><a href="#file模块新建一个文件或目录" class="headerlink" title="file模块新建一个文件或目录"></a>file模块新建一个文件或目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible spark -m file -a &quot;path=/usr/local/spark/conf/slaves state=touch&quot;</span><br></pre></td></tr></table></figure>
<p>这里<code>state=touch</code>表示新建文件，而<code>state=directory</code>则表示新建目录。这里也可以是用<code>mode</code>来指定创建的文件或目录的权限<code>mode=&#39;u=rw,g=r,o=r&#39;</code>或者<code>mode=0755</code></p>
<h4 id="file模块递归设置文件的属主或属组"><a href="#file模块递归设置文件的属主或属组" class="headerlink" title="file模块递归设置文件的属主或属组"></a>file模块递归设置文件的属主或属组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible spark -m file -a &quot;path=/usr/local/spark owner=spark group=spark recurse=yes&quot;</span><br></pre></td></tr></table></figure>
<p><code>owner</code>设置属主，<code>group</code>设置属组，<code>recurse</code>设置是否对目录进行递归进行设置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/10/31/Mac%E4%B8%8A%E5%88%B6%E4%BD%9CLinux%E7%9A%84U%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/31/Mac%E4%B8%8A%E5%88%B6%E4%BD%9CLinux%E7%9A%84U%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98/" class="post-title-link" itemprop="url">Mac上制作Linux的U盘启动盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-31 10:05:33" itemprop="dateCreated datePublished" datetime="2018-10-31T10:05:33+08:00">2018-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在windows上制作Linux的U盘启动盘非常容易，有很多工具，比如软碟通UltralISO、deepin深度启动盘制作工具等，只要正确使用这些工具就能很容易地制作一个U盘启动盘。</p>
<p>换了Mac电脑后，有时候要给服务器装Linux操作系统，还是找一台windows电脑来制作U盘启动盘，十分不方便。其实用Mac也能很容易地制作U盘启动盘，并且不需要借助什么工具，用dd命令就能完成U盘启动盘的制作。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>插入U盘，使用diskutil指令来查看U盘的挂载点</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diskutil list</span><br></pre></td></tr></table></figure>
<p> 系统输出类似如下的内容</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># joey @ joey-Mac in ~ [9:45:27]</span></span><br><span class="line">$ diskutil list</span><br><span class="line">/dev/disk0 (internal):</span><br><span class="line">   <span class="comment">#:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      GUID_partition_scheme                         24.0 GB    disk0</span><br><span class="line">   1:                        EFI EFI                     314.6 MB   disk0s1</span><br><span class="line">   2:                 Apple_APFS                         23.6 GB    disk0s2</span><br><span class="line"></span><br><span class="line">/dev/disk1 (internal, physical):</span><br><span class="line">   <span class="comment">#:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      GUID_partition_scheme                        *1.0 TB     disk1</span><br><span class="line">   1:                        EFI EFI                     209.7 MB   disk1s1</span><br><span class="line">   2:                 Apple_APFS Container disk2         900.7 GB   disk1s2</span><br><span class="line">   3:       Microsoft Basic Data BOOTCAMP                99.3 GB    disk1s3</span><br><span class="line"></span><br><span class="line">/dev/disk2 (synthesized):</span><br><span class="line">   <span class="comment">#:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:      APFS Container Scheme -                      +900.7 GB   disk2</span><br><span class="line">                                 Physical Store disk1s2</span><br><span class="line">   1:                APFS Volume CoreStorage Fusion      576.8 GB   disk2s1</span><br><span class="line">   2:                APFS Volume Preboot                 44.0 MB    disk2s2</span><br><span class="line">   3:                APFS Volume Recovery                512.4 MB   disk2s3</span><br><span class="line">   4:                APFS Volume VM                      6.4 GB     disk2s4</span><br><span class="line"></span><br><span class="line">/dev/disk3 (external, physical):</span><br><span class="line">   <span class="comment">#:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:     FDisk_partition_scheme                        *15.7 GB    disk3</span><br><span class="line">   1:               Windows_NTFS joey                    15.7 GB    disk3s1</span><br></pre></td></tr></table></figure>
<p> 可以看到，我的U盘大小是16GB，对应上面输出的挂载点应该是位于<code>/dev/disk3</code></p>
</li>
<li><p>在写入系统镜像前，首先需要umount这个U盘，使用如下指令</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diskutil unmountDisk /dev/disk3</span><br></pre></td></tr></table></figure>
<p> 会输出如下内容表示正确unmount</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># joey @ joey-Mac in ~ [9:45:34]</span></span><br><span class="line">$ diskutil unmountDisk /dev/disk3</span><br><span class="line">Unmount of all volumes on disk3 was successful</span><br></pre></td></tr></table></figure>
<p> 此时，Mac的Finder中已经看不到之前挂载上的U盘了，但是使用<code>diskutil list</code>命令还是能够看到U盘的信息</p>
</li>
<li><p>使用dd指令写入Linux系统镜像到U盘 </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/Users/joey/Downloads/CentOS-7-x86_64-DVD-1804.iso of=/dev/disk3 bs=1M</span><br></pre></td></tr></table></figure>
<p> 这里有一点需要注意，有些教程可能写的<code>bs=1m</code>，这里如果你的电脑装了GNU Coreutils，就是那个让<code>ls</code>能够彩色化输出的软件，这里用1m就会报错，报错内容为<code>dd: invalid number: ‘1m’</code>，这里把m大写就能很容易解决这个问题，但是究竟是什么原因造成1m不行的我也不是很清楚，只知道一个解决的办法。</p>
<p> 之后会输出如下，表示写入完成，大概要等几分钟</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># joey @ joey-Mac in ~ [9:49:37] C:1</span></span><br><span class="line">$ sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/Users/joey/Downloads/CentOS-7-x86_64-DVD-1804.iso of=/dev/disk3 bs=1M</span><br><span class="line">Password:</span><br><span class="line">4263+0 records <span class="keyword">in</span></span><br><span class="line">4263+0 records out</span><br><span class="line">4470079488 bytes (4.5 GB, 4.2 GiB) copied, 446.25 s, 10.0 MB/s</span><br></pre></td></tr></table></figure>
<p> 经过如上几个步骤，用Mac制作的U盘启动盘就制作完成了。</p>
</li>
</ol>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><p>U盘制作启动盘之后U盘的可能无法被Mac系统读取了，会报一个错误，可见空间也会变的很小，这时候可以重新格式化U盘来进行恢复</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/10/29/sed%E4%B8%AD%E5%8F%8D%E6%96%9C%E6%9D%A01%E7%9A%84%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/29/sed%E4%B8%AD%E5%8F%8D%E6%96%9C%E6%9D%A01%E7%9A%84%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">sed中\1的用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-29 17:26:32" itemprop="dateCreated datePublished" datetime="2018-10-29T17:26:32+08:00">2018-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在看别人写的shell脚本时看到这样一个sed指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i.bak -e<span class="string">&#x27;s/\(LOBJS=.*\)/\1 bwtindex.o rle.o rope.o bwt.o is.o/g&#x27;</span> bwa/Makefile</span><br></pre></td></tr></table></figure>
<p>这里面使用了<code>sed &#39;s/要被取代的字符串/新的字符串/g&#39; file</code>的方式来对文本中指定的字符串进行全局替换，这里g代表的是global，之前面试又被问到过sed全局如何替换，当时就是忘记了最后应该要加<code>/g</code>，在这个命令中，新的字符串的内容中有一个<code>\1</code>之前从来没有遇到过，不知道具体的作用是什么，于是就去查找了一些资料进行学习。</p>
<p>在sed中，要被匹配的字符串可以用正则匹配来进行模式匹配，而用括号括起来的一个正则匹配串可以称为一个模式，而<code>\1-9</code>就是用来指代第一个、第二个、……、第九个模式在匹配到的字符串中的内容。在sed中一共可以记录9个模式，在某些需要保留原有字符串的一部分并添加一部分内容的时候就会很有用。</p>
<p>举个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> abc123 | sed <span class="string">&#x27;s/\([a-z]*\)\([0-9]&#123;3&#125;\)/\2\1/g&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个例子的输出就是<code>123abc</code>，先来看下正则匹配的内容，一共有2个位于括号中的模式，第一个模式匹配的是出现次数任意多的小写字母，第二个模式匹配的是出现三次的数字，模式都用括号括起来，但是括号要使用反斜杠进行转义。在这个正则匹配中，<code>\1</code>代表的就是第一个模式匹配的内容，即abc,<code>\2</code>代表的是第二个模式匹配的内容，即123，然后替换成什么内容呢？就是交换这两个匹配的模式，把<code>\2</code>放到<code>\1</code>前面，就是123在前面，abc在后面，变成了123abc，就是这样简单，这是一个简单的交换匹配到的内容的例子，我们还可以在模式中插入内容，举例子来说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> abc123 | sed <span class="string">&#x27;s/\([a-z]*\)\([0-9]&#123;3&#125;\)/\1xx\2/g&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这个例子的输出就是在abc和123之间插入了两个字母xx，最终的结果是abcxx123，知道C当中的printf函数的同学可以把这里的<code>\1\2</code>理解成两个占位符，具体的内容由前面匹配到的模式的内容来进行填充，按照正则匹配中的顺序进行记录，最多记录9个。</p>
<p>这里在说一点题外话，<code>sed -i</code>我们知道是直接在原文件中进行修改，但是<code>-i</code>后面其实是可以加参数的，在最上面那个例子里面就是加了<code>.bak</code>作为<code>-i</code>的参数，这里的意思是，直接在原文件进行修改，但是将原文件保存为<code>filename.bak</code>，即在最后加上<code>.bak</code>进行备份。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/10/29/Gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0C-C-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/29/Gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0C-C-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Gradle中添加C/C++代码编译打包流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-29 15:10:41" itemprop="dateCreated datePublished" datetime="2018-10-29T15:10:41+08:00">2018-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>写过JNI代码的同学应该都有遇到过这样的问题，我们可以很方便的使用Maven、Gradle等工具将我们写好的Java代码打包成一个jar包进行发布，但是当我们的代码当中包含有C&#x2F;C++的代码时，我们可能需要额外再去运行一次make指令去编译C&#x2F;C++的代码，并将编译出的库和jar包一起发布（在大多数情况下so文件和jar包是分开的）。实际上，我们可以使用Gradle在打包的同时自动编译我们的C&#x2F;C++代码，同时将so文件打包到jar包之中，这样在运行jar包时不需要指定<code>java.library.path</code>也能正确读取到so文件，并且发布时只有一个文件，更为方便。</p>
<h4 id="Exec-Task"><a href="#Exec-Task" class="headerlink" title="Exec Task"></a>Exec Task</h4><p>我们知道，Gradle的执行过程可以分为很多的Task进行，要实现Gradle自动编译C&#x2F;C++代码我们需要首先了解一下Exec Task。Exec Task是用来执行一个命令行语句的，例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> stopTomcat(type: Exec) &#123;</span><br><span class="line">	workingDir <span class="string">&#x27;../tomcat/bin&#x27;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//on windows:</span></span><br><span class="line">	commandLine <span class="string">&#x27;cmd&#x27;</span>, <span class="string">&#x27;/c&#x27;</span>, <span class="string">&#x27;stop.bat&#x27;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//on linux:</span></span><br><span class="line">	commandLine <span class="string">&#x27;./stop.sh&#x27;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//store the output instead of printing to the console:</span></span><br><span class="line">	standardOutput = <span class="keyword">new</span> ByteArrayOutputStream()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//extension method stopTomcat.output() can be used to obtain the output:</span></span><br><span class="line">	ext.output = &#123;</span><br><span class="line">		<span class="keyword">return</span> standardOutput.toString()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体有关这个Task的详细说明可以看这个：<a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html">https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html</a></p>
<h4 id="使用Exec-Task来编译C-C-代码"><a href="#使用Exec-Task来编译C-C-代码" class="headerlink" title="使用Exec Task来编译C&#x2F;C++代码"></a>使用Exec Task来编译C&#x2F;C++代码</h4><p>当然，Exec Task用来编译C&#x2F;C++代码使用的是make指令，如果使用的是cmake，也可以先执行cmake再执行make，无非是多加几个Exec Task。这里具体的写法如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String cpath = <span class="string">&quot;native&quot;</span></span><br><span class="line">String libname = <span class="string">&quot;libpairhmm&quot;</span></span><br><span class="line"><span class="keyword">task</span> buildLib(type: Exec) &#123;</span><br><span class="line">	workingDir <span class="string">&quot;$cpath&quot;</span></span><br><span class="line">	outputs.files <span class="string">&quot;$cpath/libpairhmm*&quot;</span></span><br><span class="line">	outputs.dir <span class="string">&quot;$cpath/pairhmm&quot;</span></span><br><span class="line">	commandLine <span class="string">&quot;make all&quot;</span></span><br><span class="line">	String home = System.properties.<span class="string">&quot;java.home&quot;</span></span><br><span class="line">	<span class="comment">//strip the trailing jre</span></span><br><span class="line">	String corrected = home.endsWith(<span class="string">&quot;jre&quot;</span>) ? home.substring(<span class="number">0</span>, home.length() - <span class="number">4</span>) : home</span><br><span class="line">	environment JAVA_HOME : corrected</span><br><span class="line">	<span class="keyword">doFirst</span> &#123; <span class="keyword">println</span> <span class="string">&quot;using $home -&gt; $corrected as JAVA_HOME&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clean &#123;</span><br><span class="line">	<span class="keyword">delete</span> <span class="string">&quot;$cpath/pairhmm&quot;</span></span><br><span class="line">	<span class="keyword">delete</span> <span class="string">&quot;$cpath/$libname*&quot;</span></span><br><span class="line">	<span class="keyword">delete</span> <span class="keyword">fileTree</span>(<span class="string">&quot;$cpath&quot;</span>) &#123; <span class="keyword">include</span> <span class="string">&quot;$libname*&quot;</span>, <span class="string">&quot;*.o&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processResources &#123;</span><br><span class="line">	dependsOn buildLib</span><br><span class="line">	<span class="keyword">from</span> cpath</span><br><span class="line">	<span class="keyword">include</span> <span class="string">&quot;$libname*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里buildLib这个task就是一个Exec Task，其中定义的流程就是执行make all指令来编译C&#x2F;C++代码，clean的作用就是清除编译产生的lib文件和o文件（在调用gradle clean的时候调用清除工作），processResources即处理资源文件，其作用就是将编译产生的库文件拷贝到jar包当中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/10/26/spark/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95Spark%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/26/spark/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95Spark%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">远程调试Spark程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-26 18:40:25" itemprop="dateCreated datePublished" datetime="2018-10-26T18:40:25+08:00">2018-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们在写Spark程序的时候免不了要对我们的代码进行debug，在代码当中打上断点来查看程序执行过程中各个变量的变化情况。我一般使用Intellij IDEA来写Spark程序，可以直接在其中以local的方式运行Spark程序，也可以在其中打上断点进行调试，但这样做有一些问题：</p>
<ol>
<li>我们只能对Spark driver端的程序进行打断点debug；</li>
<li>Spark很多代码都是惰性执行的，很多代码都需要有action才能触发，在这之前打断点没有意义，真正的Task执行逻辑位于Executor当中；</li>
<li>对于某些运算量比较大或者内存消耗比较多的程序来说，本地电脑不能运行；</li>
<li>这样只能观察代码在local模式下运行的是否正确，无法对在集群中运行的代码进行调试。</li>
</ol>
<p>之前所说的几点问题我在之前一般采用比较低效率的方式来进行debug，即在代码当中加入一些log信息，利用log信息来调试代码，这样当Spark程序在集群中运行时，可以在web UI的Executor的stdout和stderr中查看我们留下的log信息。这样做可以解决一些问题，但是十分低效，debug的信息需要添加改动时都需要重新编译程序，并且打印log信息的方式并不能很完整地观察到所有变量的变化情况。但这样做确实解决了一些问题，比如我们可以对Executor真正执行Task逻辑的代码进行调试，也无需考虑惰性执行的过程，Spark的所有RDD的transform的行为都会反映到每个Executor执行的stdout和stderr信息当中；这些代码都可以在服务器集群当中运行进行调试，不用担心本地电脑性能不够的问题，本地电脑只需要打开浏览器查看Spark的web UI即可，或者使用终端来查看一些信息；可以在集群当中调试代码，不需要局限于local模式下。</p>
<p>但我始终认为这样的debug方式是低效的，并且不是一个正常的程序员应该有的debug方式，之前有想过肯定有具体的方法来解决这样的调试问题，Intellij IDEA当中功能非常多，肯定有这样的功能来解决这个问题。近期又要写一些Spark程序，并且输入数据非常大，计算量也很大，我在本地电脑上根本没办法debug，于是想到了去查找一些资料来解决远程调试Spark程序的问题。其实Intellij IDEA或者Eclipse这样的IED都会有remote debug这样的功能，以Intellij IDEA为例，在Run-Edit Configurations菜单中我们可以添加一个Remote的Configurations，这就是Intellij IDEA为我们提供的远程调试的功能。这里对Spark程序的调试主要分两种——Driver程序调试和Executor程序调试。</p>
<h4 id="Driver程序调试"><a href="#Driver程序调试" class="headerlink" title="Driver程序调试"></a>Driver程序调试</h4><p>Driver程序在远程进行调试时，需要在spark-submit的参数中增加一个配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--conf spark.driver.extraJavaOptions=-agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y,address=5005</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/10/26/spark/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95Spark%E7%A8%8B%E5%BA%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/10/25/spark/spark%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Spark%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/25/spark/spark%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Spark%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Spark运行原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-25 15:43:44" itemprop="dateCreated datePublished" datetime="2018-10-25T15:43:44+08:00">2018-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spark%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">Spark源码阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>spark的运行原理在大数据开发岗面试过程中是经常被问到的一个问题，我第一次被问到这个问题的时候有点摸不着头脑，这么大的一个问题我究竟应该怎样回答呢？是去描述一下spark的架构组成还是说一下底层的调用细节？后来查找了一些资料，看了一些书之后对这个问题有了一些理解，其实提这个问题的人可能最希望我们回答的是Spark运行的过程细节，简单来说就是把某个Spark程序从提交到执行完成中间经历了哪些步骤描述出来。如果在描述的过程中能够加入一些对Spark底层源码细节的解释会给提问者留下比较好的印象，认为你不仅仅是停留在使用Spark上，还对底层源码的原理有所了解。</p>
<h3 id="简单描述Spark的运行原理"><a href="#简单描述Spark的运行原理" class="headerlink" title="简单描述Spark的运行原理"></a>简单描述Spark的运行原理</h3><blockquote>
<p>用户使用spark-submit提交一个作业之后，会首先启动一个driver进程，driver进程会向集群管理器（standalone、YARN、Mesos）申请本次运行所需要的资源（这里的资源包括core和memory，可以在spark-submit的参数中进行设置），集群管理器会根据我们需要的参数在各个节点上启动executor。申请到对应资源之后，driver进程就会开始调度和执行我们编写的作业代码。作业会被提交给DAGScheduler，DAGScheduler会根据作业中RDD的依赖关系将作业拆分成多个stage，拆分的原则就是根据是否出现了宽依赖，每个stage当中都会尽可能多的包含连续的窄依赖。每个stage都包含了作业的一部分，会生成一个TaskSet提交给底层调度器TaskScheduler，TaskScheduler会把TaskSet提交到集群当中由executor进行执行。Task的划分是根据数据的partition进行划分，一个partition会划分为一个task。如此循环往复，直至执行完编写的driver程序的所有代码逻辑，并且计算完所有的数据。</p>
</blockquote>
<p>简单的运行流程如下图：</p>
<center>
<img style="border: none" src="https://user-gold-cdn.xitu.io/2018/9/30/16629a724b5034a3?w=1326&h=359&f=png&s=54756" width=60% height=60%>

<p>图一 spark运行流程</p>
</center>

<h3 id="SparkContext"><a href="#SparkContext" class="headerlink" title="SparkContext"></a>SparkContext</h3><p>Spark程序的整个运行过程都是围绕spark driver程序展开的，spark driver程序当中最重要的一个部分就是SparkContext，SparkContext的初始化是为了准备Spark应用程序的运行环境，SparkContext主要是负责与集群进行通信、向集群管理器申请资源、任务的分配和监控等。</p>
<p>driver与worker之间的架构如下图，driver负责向worker分发任务，worker将处理好的结果返回给driver。</p>
<center>
<img style="border: none" src="https://user-gold-cdn.xitu.io/2018/9/30/16629ab664dc9649?w=344&h=318&f=png&s=18157" width=20%>

<p>图二 driver架构</p>
</center>

<p>SparkContext的核心作用是初始化Spark应用程序运行所需要的核心组件，包括高层调度器DAGScheduler、底层调度器TaskScheduler和调度器的通信终端SchedulerBackend，同时还会负责Spark程序向Master注册程序等。Spark应用当中的RDD是由SparkContext进行创建的，例如通过SparkContext.textFile()、SparkContext.parallel()等这些API。运行流程当中提及的向集群管理器Cluster Manager申请计算资源也是由SparkContext产生的对象来申请的。接下来我们从源码的角度学习一下SparkContext，关于SparkContext创建的各种组件，在SparkContext类中有这样一段代码来创建这些组件：</p>
<img style="border: none; margin-left: 0; margin-right: 0" src="https://user-gold-cdn.xitu.io/2018/10/25/166a8d2fbb706104?w=1246&h=220&f=png&s=63332" width=45%>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/10/25/spark/spark%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Spark%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/05/23/java/Gradle%E4%B8%AD%E4%BD%BF%E7%94%A8proguard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/23/java/Gradle%E4%B8%AD%E4%BD%BF%E7%94%A8proguard/" class="post-title-link" itemprop="url">Gradle中使用proguard</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-23 21:04:45" itemprop="dateCreated datePublished" datetime="2018-05-23T21:04:45+08:00">2018-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近做了一个Java项目，老板让我们将核心部分的代码进行混淆，防止jar包被反编译出来。Java项目是基于Gradle进行构建的，使用了shadowJar这个插件将源码生成的jar包和所有的依赖的jar包打包到一起，称为一个fat-jar。我之前单独使用过proguard的gui，也使用过maven的proguard plugin以及sbt的plugin，都踩了很多坑最终混淆成功了，以为这次应该很轻松能完成任务，但事实上我遇到了很多之前没有遇到过的问题，现在将我解决这个问题的每个阶段记录下来。</p>
<h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p>下载了最新的proguard6.0.3，执行proguardgui.sh，图形界面出来之后，写好一个配置文件并load进去，配置文件中将包含依赖的fat-jar作为输入，libraryjars只添加了<code>jre/lib/rt.jar</code>，因为其他库文件都包含在了fat-jar包当中，这样混淆有一个问题就是会去混淆依赖的库，虽然可以通过<code>keep class</code>来保持依赖的库不被混淆，但是proguard还是会去遍历所有的依赖库中的内容，导致混淆的时间非常长。这对于我来说是不能接受的，我现在都还不知道我写的混淆配置文件能不能让混淆后的jar包正常运行，如果测试一次要花这么长时间，肯定是不能按时完成任务的，而且整个调试的过程会非常痛苦。我看了一下jar包有200M左右，但实际上我们源码对应的jar包只有5M左右，其他的内容都是依赖的库，实际上我是不需要去混淆这些依赖，proguard花费时间去遍历这些依赖是没有意义的。</p>
<h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>我先不用shadowJar进行打包，只使用jar任务编译出一个不包含依赖的jar包，只对这个不包含依赖的jar包进行混淆，把其依赖的库通过proguard配置文件中的<code>-libraryjars</code>参数添加进去（不添加进去会出现找不到依赖的库的问题）。这样proguard就只会混淆我们所写的代码，不会涉及到依赖的库，代码很快就混淆完了。混淆后的库文件中包含有<code>MAINIFEST.MF</code>文件，<code>Class-Path</code>中记录了所依赖的库文件的路径，使得独立的jar包也能正常运行。我写的混淆配置文件混淆的力度并不是很大，我以为程序能够正常运行，但是却并没有如我所愿。</p>
<h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><p>独立混淆的jar包在混淆环节并没有出错，但是执行的时候却遇到了一个很奇怪的问题，我追踪代码发现在某一个地方使用了<code>ClassLoader.getResource(packageName)</code>方法去获取在packageName包下的所有资源，这个方法在jar包没有混淆之前是能正确找到packageName下的所有资源，但是混淆之后这个方法就什么都获取不到了。为了探究原因，我关闭了proguard的所有功能，包括optimize、obfuscate、shrink，相当于不对输入的jar包做任何处理，最后输出的jar包还是会有这个问题。同时，我把混淆前的jar包和不开启proguard任何功能输出的jar包使用JAPICC进行比较，发现里面的内容是完全一致的。查找资料发现proguard会对jar包进行优化，以期减少其大小。默认情况下，proguard会删除jar中的目录元素，导致ClassLoader().getResource（）方法找不到对应的资源，只需要在使用时加上<code>-keepdirectories</code>选项即可。附上官方文档的说明：</p>
<blockquote>
<p><strong>-keepdirectories</strong> [<em>directory_filter</em>]<br>Specifies the directories to be kept in the output jars (or aars, wars, ears, zips, apks, or directories). By default, directory entries are removed. This reduces the jar size, but it may break your program if the code tries to find them with constructs like “com.example.MyClass.class.getResource(“”)”. You’ll then want to keep the directory corresponding to the package, “-keepdirectories com.example”. If the option is specified without a filter, all directories are kept. With a filter, only matching directories are kept. For instance, “-keepdirectories mydirectory” matches the specified directory, “-keepdirectories mydirectory&#x2F;*” matches its immediate subdirectories, and “-keepdirectories mydirectory&#x2F;**” matches all of its subdirectories.</p>
</blockquote>
<h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><p>最后的要求还是需要将源码和依赖的库打包到一起，需要在shadowJar打包之前先将源码产生的jar包进行混淆，shadowJar任务的输入改成这个混淆后的jar包即可。proguard实际上也能作为gradle的一个插件进行使用，可以在<code>build.gradle</code>当中加入一个proguard的task进行混淆，proguard官网提供了一种使用方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    flatDir <span class="attr">dirs:</span> <span class="string">&#x27;/usr/local/java/proguard/lib&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath <span class="string">&#x27;:proguard:&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义task的方式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task myProguardTask(<span class="attr">type:</span> proguard.gradle.ProGuardTask) &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样需要自己手动下载proguard，并存放在编译gradle的服务器上，十分不方便。还有一种方式比较方便，每次会自动下载需要的jar包：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter() <span class="comment">// for shadow plugin</span></span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath <span class="string">&#x27;net.sf.proguard:proguard-gradle:6.0.3&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我所定义的proguard的混淆任务如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task obfuscate(<span class="attr">type:</span> proguard.gradle.ProGuardTask) &#123;</span><br><span class="line">  injars jar</span><br><span class="line">  outjars <span class="string">&quot;$buildDir/libs/$&#123;project.name&#125;-pg.jar&quot;</span></span><br><span class="line">  libraryjars <span class="string">&quot;$&#123;System.getProperty(&#x27;java.home&#x27;)&#125;/lib/rt.jar&quot;</span></span><br><span class="line">  libraryjars files(configurations.compile.collect())</span><br><span class="line"></span><br><span class="line">  useuniqueclassmembernames</span><br><span class="line"></span><br><span class="line">  dontshrink</span><br><span class="line">  dontoptimize</span><br><span class="line">  dontnote</span><br><span class="line">  dontwarn</span><br><span class="line"></span><br><span class="line">  <span class="comment">//keepnames &#x27;class ** &#123; *; &#125;&#x27;</span></span><br><span class="line">  configuration <span class="string">&#x27;proguard.pro&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>injars</code>直接写jar即可，会得到jar任务的输出（即源码编译产生的jar），<code>outjars</code>输出到<code>build/libs</code>路径下，<code>rt.jar</code>也许要添加，jre的路径可以使用<code>$&#123;System.getProperty(&#39;java.home&#39;)&#125;</code>获得。另外，依赖的所有库可以通过一种很简洁的方式表述出来，不需要一个依赖一个依赖的添加，<code>libraryjars files(configurations.compile.collect())</code>，这句话会把compile环节所依赖的所有库文件的获取到，并添加到libraryjar当中。proguard的配置参数可以直接在gradle的task中写，一般来说是将普通的proguard参数去掉前面的-，参数的值需要写到一个字符串当中，遇到配置字符串需要换行的配置情况需要在最后加上一个\。<br>同时，还需要将混淆产生的jar包作为shadowJar任务的输入才能将这个混淆的jar包和依赖打包到一起，具体写法如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task myShadow(<span class="attr">type:</span> ShadowJar) &#123;</span><br><span class="line">  baseName = jar.baseName</span><br><span class="line">  from obfuscate</span><br><span class="line">  configurations = [project.configurations.runtime]</span><br><span class="line">  classifier = <span class="string">&#x27;shadow&#x27;</span></span><br><span class="line">  ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>from指明了需要打包的jar的来源，这里指定obfuscate就是之前写的obfuscate任务的输出，configurations指定了配置文件，指定之后会根据这个配置文件找到所有的依赖库文件，这里指定的是打包compile环节依赖的库文件，并且<code>[project.configurations.runtime]</code>实际上是default <code>shadowJar</code> task的默认配置。</p>
<p>这里有一个坑需要注意，如果你使用了默认的shadowJar任务（shadowJar），最后生成的fat-jar会包含有依赖库、没混淆的代码、混淆的代码三部分，正如Stack Overflow上这个问题所描述的一样：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43643609/gradle-shadowjar-output-contains-obfuscated-and-non-obfuscated-classes?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa">https://stackoverflow.com/questions/43643609/gradle-shadowjar-output-contains-obfuscated-and-non-obfuscated-classes?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a><br>这里产生这种情况的原因是，默认的shadowJar任务总会将main文件夹中的源文件添加到输入当中，要解决这个问题就是自己定义一个type为shadowJar的task，不要去使用默认的shadowJar任务，其实这个问题在shadowJar官方说明文档当中也写到了：</p>
<blockquote>
<p>The built in shadowJar task only provides an output for the main source set of the project. It is possible to add arbitrary ShadowJar tasks to a project. When doing so, ensure that the configurations property is specified to inform Shadow which dependencies to merge into the output.</p>
</blockquote>
<p>官方提供了一个例子可以将test中的源文件与testRuntime中依赖的库文件进行打包的方法，也说到了默认的shadowJar任务只能将main中的源文件进行打包，也提示了我们如果要用proguard混淆之后的jar作为输入需要自己定义shadowJar任务，不能使用默认的shadowJar任务。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task testJar(<span class="attr">type:</span> ShadowJar) &#123;</span><br><span class="line">  classifier = <span class="string">&#x27;tests&#x27;</span></span><br><span class="line">  from sourceSets.test.output</span><br><span class="line">  configurations = [project.configurations.testRuntime]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.guardsquare.com/en/proguard/manual/usage">https://www.guardsquare.com/en/proguard/manual/usage</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oschina.net/question/237480_166440">https://www.oschina.net/question/237480_166440</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43643609/gradle-shadowjar-output-contains-obfuscated-and-non-obfuscated-classes?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa">https://stackoverflow.com/questions/43643609/gradle-shadowjar-output-contains-obfuscated-and-non-obfuscated-classes?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a></li>
<li><a target="_blank" rel="noopener" href="http://imperceptiblethoughts.com/shadow/">http://imperceptiblethoughts.com/shadow/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.huangyunkun.com/2013/12/23/gradle_with_proguard/">https://www.huangyunkun.com/2013/12/23/gradle_with_proguard/</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiayi771.github.io/2018/04/16/linux/CentOS%E5%AE%89%E8%A3%85%E9%AB%98%E7%89%88%E6%9C%ACgcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/blogImg/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joey's Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/16/linux/CentOS%E5%AE%89%E8%A3%85%E9%AB%98%E7%89%88%E6%9C%ACgcc/" class="post-title-link" itemprop="url">CentOS安装高版本gcc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-16 19:37:29" itemprop="dateCreated datePublished" datetime="2018-04-16T19:37:29+08:00">2018-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-28 11:47:21" itemprop="dateModified" datetime="2025-04-28T11:47:21+08:00">2025-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近需要在CentOS 7.2上安装matlab，发现matlabR2017b Linux版本安装需要gcc 4.9.x，但是CentOS 7.2 使用yum安装的gcc版本最高为4.8.5，于是决定将gcc版本进行升级。升级gcc一般建议采用编译安装的方式，但是这种方式比较麻烦，需要先编译安装mpfr、gmp、mpc等，于是在网上找到了一种通过yum比较方便的升级方式，而且可以随时在bash、zsh等当中切换各种gcc版本，特记录在此。</p>
<h2 id="gcc-4-9安装"><a href="#gcc-4-9安装" class="headerlink" title="gcc 4.9安装"></a>gcc 4.9安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install centos-release-scl</span><br><span class="line">sudo yum install devtoolset-3-toolchain</span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-3 bash</span><br></pre></td></tr></table></figure>
<p>这里scl enable就是用来切换不同版本的gcc的。这个切换是临时的，表示在bash中临时切换到gcc4.9的工作环境，当使用<code>exit</code>指令之后，就会回退到原始的gcc版本，可以使用<code>scl -l</code>来查看所有可以切换的开发工具集。</p>
<h2 id="gcc-5-2"><a href="#gcc-5-2" class="headerlink" title="gcc 5.2"></a>gcc 5.2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install centos-release-scl</span><br><span class="line">sudo yum install devtoolset-4-toolchain</span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-4 bash</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiayi Liu"
      src="/assets/blogImg/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiayi Liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiayi771" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiayi771" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liujiayi771@gmail.com" title="E-Mail → mailto:liujiayi771@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiayi Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
